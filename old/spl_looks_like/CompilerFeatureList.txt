// Compiler features
- default args
- function overloading
- type or @typedef double|float decimal
    - This means that the compiler has to always check if a type is a union type
- transpiles to C and is valid C and C++
- builtin runtime asserts
- builtin vectors
- builtin dynamic arrays
- builtin strings
- builtin mats
- generics
- do an inheritance type thing, but just make it so that when you compose something you can easily the members
- variable arguments
- auto dereferencing . instead of ->
- auto initialization
    - if you don't want a variable to be initialized: int x = ---
- compile time type info
    - @typeof()
- namespacing
    - Think how to do this well?


// The way @typeof() is going to work is if it's an identifier or literal replace it with the correct type
// then you can take the type and replace that with a enumValue registered in the C generated code
// For example #assert(@typeof(6) == @Typeof(int)) => #assert(PRIMITIVE_INT == @Typeof(PRIMITIVE_INT)); (Passes)
// ----- or -----
// string testVar = "Test Code!";
// #assert(@typeof(testVar) == @Typeof(int)) => #assert(PRIMITIVE_STRING == PRIMITIVE_INT); (Fails)
// ----- or -----
// User<Admin> user = User.create();
// user.login()
// #assert(@typeof(user) == @Typeof(int)) => #assert(STRUCT_TYPE_USER_ADMIN == PRIMITIVE_INT); (Fails)
